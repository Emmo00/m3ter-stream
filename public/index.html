<!doctype html>

<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>M3tering Stream Viewer</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Space Mono", "Courier New", monospace;
        background: #e8e4d9;
        min-height: 100vh;
        padding: 24px;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        background: #ffffff;
        border: 3px solid #1a1a1a;
        box-shadow: 8px 8px 0 #1a1a1a;
      }

      .header {
        background: #ffd803;
        color: #1a1a1a;
        padding: 28px 30px;
        border-bottom: 3px solid #1a1a1a;
      }

      .header h1 {
        font-size: 2.2em;
        font-weight: 700;
        letter-spacing: -1px;
        text-transform: uppercase;
      }

      .header .stream-id {
        font-size: 0.8em;
        font-weight: 500;
        word-break: break-all;
        margin-top: 8px;
        background: #1a1a1a;
        color: #ffd803;
        padding: 6px 10px;
        display: inline-block;
      }

      .status-bar {
        padding: 16px 30px;
        background: #ffffff;
        border-bottom: 3px solid #1a1a1a;
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
        gap: 12px;
      }

      .status {
        display: flex;
        align-items: center;
        gap: 10px;
        font-weight: 700;
        text-transform: uppercase;
        font-size: 0.85em;
      }

      .status-indicator {
        width: 14px;
        height: 14px;
        border: 2px solid #1a1a1a;
        background: #ff6b6b;
      }

      .status-indicator.connected {
        background: #51cf66;
      }

      .stats {
        display: flex;
        gap: 24px;
        font-size: 0.9em;
        font-weight: 600;
        text-transform: uppercase;
      }

      .stats span {
        font-weight: 800;
        color: #1a1a1a;
        background: #a8f0c6;
        padding: 2px 8px;
        border: 2px solid #1a1a1a;
      }

      .controls {
        padding: 16px 30px;
        background: #f0f0f0;
        border-bottom: 3px solid #1a1a1a;
        display: flex;
        gap: 12px;
        align-items: center;
      }

      .btn {
        padding: 10px 20px;
        border: 3px solid #1a1a1a;
        cursor: pointer;
        font-size: 0.85em;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        transition: transform 0.1s, box-shadow 0.1s;
        box-shadow: 4px 4px 0 #1a1a1a;
        font-family: inherit;
      }

      .btn:hover {
        transform: translate(-2px, -2px);
        box-shadow: 6px 6px 0 #1a1a1a;
      }

      .btn:active {
        transform: translate(2px, 2px);
        box-shadow: 2px 2px 0 #1a1a1a;
      }

      .btn-primary {
        background: #ffd803;
        color: #1a1a1a;
      }

      .btn-secondary {
        background: #ffffff;
        color: #1a1a1a;
      }

      .messages-container {
        height: calc(100vh - 400px);
        min-height: 400px;
        overflow-y: auto;
        padding: 24px 30px;
        background: #ffffff;
      }

      .message-card {
        background: #ffffff;
        border: 3px solid #1a1a1a;
        box-shadow: 5px 5px 0 #1a1a1a;
        padding: 16px;
        margin-bottom: 16px;
      }

      .message-header {
        display: flex;
        justify-content: space-between;
        margin-bottom: 12px;
        font-size: 0.8em;
        font-weight: 600;
        text-transform: uppercase;
      }

      .message-header .timestamp {
        background: #e8e4d9;
        padding: 4px 8px;
        border: 2px solid #1a1a1a;
      }

      .message-header .m3ter-id {
        font-weight: 800;
        background: #a8f0c6;
        padding: 4px 8px;
        border: 2px solid #1a1a1a;
        color: #1a1a1a;
      }

      .message-content {
        font-family: "Space Mono", "Courier New", monospace;
        font-size: 0.85em;
        word-break: break-all;
        background: #f5f5f5;
        padding: 12px;
        border: 2px solid #1a1a1a;
        max-height: 200px;
        overflow-y: auto;
      }

      .empty-state {
        text-align: center;
        padding: 60px 20px;
        color: #1a1a1a;
      }

      .empty-state svg {
        width: 80px;
        height: 80px;
        margin-bottom: 20px;
        stroke: #1a1a1a;
        stroke-width: 2.5;
      }

      .empty-state h3 {
        font-size: 1.4em;
        text-transform: uppercase;
        font-weight: 800;
        margin-bottom: 8px;
      }

      .empty-state p {
        font-weight: 500;
      }

      .footer {
        padding: 16px 30px;
        background: #1a1a1a;
        text-align: center;
        font-size: 0.8em;
        color: #ffffff;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      .error-message {
        background: #ffe0e0;
        border-color: #ff6b6b;
        box-shadow: 5px 5px 0 #ff6b6b;
      }

      .error-message .message-header .m3ter-id {
        background: #ff6b6b;
        color: #ffffff;
      }

      .auto-scroll-toggle {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 0.85em;
        font-weight: 700;
        text-transform: uppercase;
      }

      .auto-scroll-toggle input[type="checkbox"] {
        width: 18px;
        height: 18px;
        cursor: pointer;
        accent-color: #1a1a1a;
      }

      /* Scrollbar styling */
      .messages-container::-webkit-scrollbar {
        width: 12px;
      }

      .messages-container::-webkit-scrollbar-track {
        background: #e8e4d9;
        border-left: 3px solid #1a1a1a;
      }

      .messages-container::-webkit-scrollbar-thumb {
        background: #1a1a1a;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>M3tering Stream Viewer</h1>
        <div class="stream-id">Stream: 0x567853282663b601bfdb9203819b1fbb3fe18926/m3tering/test</div>
      </div>
      <div class="status-bar">
        <div class="status">
          <div class="status-indicator" id="statusIndicator"></div>
          <span id="statusText">Connecting...</span>
        </div>
        <div class="stats">
          <div>Messages: <span id="messageCount">0</span></div>
          <div>Buffer: <span id="bufferCount">0</span></div>
          <div>Pending: <span id="pendingCount">0</span></div>
        </div>
      </div>

      <div class="controls">
        <button class="btn btn-secondary" id="clearBtn">Clear Messages</button>
        <button class="btn btn-secondary" id="pauseBtn">Pause Stream</button>
        <div class="auto-scroll-toggle">
          <input type="checkbox" id="autoScrollToggle" checked />
          <label for="autoScrollToggle">Auto-scroll</label>
        </div>
      </div>

      <div class="messages-container" id="messagesContainer">
        <div class="empty-state">
          <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M20 13V6a2 2 0 00-2-2H6a2 2 0 00-2 2v7m16 0v5a2 2 0 01-2 2H6a2 2 0 01-2-2v-5m16 0h-2.586a1 1 0 00-.707.293l-2.414 2.414a1 1 0 01-.707.293h-3.172a1 1 0 01-.707-.293l-2.414-2.414A1 1 0 006.586 13H4"
            ></path>
          </svg>
          <h3>Waiting for messages...</h3>
          <p>Messages from the Streamr network will appear here in real-time.</p>
        </div>
      </div>

      <div class="footer">Connected to Streamr Network | Real-time M3tering Data Stream</div>
    </div>

    <script>
      let ws = null;
      let messageCount = 0;
      let autoScroll = true;
      let isPaused = false;
      let messageBuffer = [];
      let lastRenderTime = 0;
      let pendingRender = false;
      const MAX_VISIBLE_MESSAGES = 50; // Reduced from 100
      const RENDER_THROTTLE_MS = 100; // Throttle rendering
      const messagesContainer = document.getElementById("messagesContainer");
      const statusIndicator = document.getElementById("statusIndicator");
      const statusText = document.getElementById("statusText");
      const messageCountEl = document.getElementById("messageCount");
      const bufferCountEl = document.getElementById("bufferCount");
      const pendingCountEl = document.getElementById("pendingCount");
      const clearBtn = document.getElementById("clearBtn");
      const pauseBtn = document.getElementById("pauseBtn");
      const autoScrollToggle = document.getElementById("autoScrollToggle");

      function connect() {
        const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
        const wsUrl = `${protocol}//${window.location.host}`;

        ws = new WebSocket(wsUrl);

        ws.onopen = () => {
          console.log("WebSocket connected");
          updateStatus("connected", "Connected to Streamr Stream");
        };

        ws.onmessage = (event) => {
          const data = JSON.parse(event.data);
          handleMessage(data);
        };

        ws.onerror = (error) => {
          console.error("WebSocket error:", error);
          updateStatus("error", "Connection Error");
        };

        ws.onclose = () => {
          console.log("WebSocket disconnected");
          updateStatus("disconnected", "Disconnected - Reconnecting...");
          setTimeout(connect, 3000);
        };
      }

      function handleMessage(data) {
        switch (data.type) {
          case "connected":
            console.log("Connected:", data.message);
            break;

          case "history":
            console.log("Received history:", data.data.length, "messages");
            bufferCountEl.textContent = data.data.length;
            // Process history messages in batches to avoid blocking UI
            processMessageBatch(data.data.map(msg => ({...msg, isNew: false})));
            break;

          case "message":
            // Add to buffer instead of immediately rendering
            if (!isPaused) {
              messageBuffer.push({data: data.data, timestamp: data.timestamp, isNew: true});
              pendingCountEl.textContent = messageBuffer.length;
              scheduleRender();
            }
            break;

          case "error":
            addError(data.message);
            break;
        }
      }

      function scheduleRender() {
        if (!pendingRender) {
          pendingRender = true;
          requestAnimationFrame(() => {
            const now = Date.now();
            if (now - lastRenderTime > RENDER_THROTTLE_MS) {
              renderBufferedMessages();
              lastRenderTime = now;
              pendingRender = false;
            } else {
              setTimeout(() => {
                renderBufferedMessages();
                lastRenderTime = Date.now();
                pendingRender = false;
              }, RENDER_THROTTLE_MS - (now - lastRenderTime));
            }
          });
        }
      }

      function renderBufferedMessages() {
        if (messageBuffer.length === 0) return;
        
        // Remove empty state if present
        const emptyState = messagesContainer.querySelector(".empty-state");
        if (emptyState) {
          emptyState.remove();
        }

        // Create document fragment for efficient DOM manipulation
        const fragment = document.createDocumentFragment();
        
        // Process messages from buffer
        const messagesToProcess = messageBuffer.splice(0, Math.min(messageBuffer.length, 10)); // Process max 10 at once
        
        messagesToProcess.forEach(({data, timestamp, isNew}) => {
          if (isNew) {
            messageCount++;
          }
          
          const messageCard = createMessageElement(data, timestamp);
          fragment.appendChild(messageCard);
        });

        // Add all messages at once
        if (fragment.children.length > 0) {
          messagesContainer.insertBefore(fragment, messagesContainer.firstChild);
        }

        // Update counts
        messageCountEl.textContent = messageCount;
        pendingCountEl.textContent = messageBuffer.length;

        // Clean up excess messages efficiently
        const messages = messagesContainer.querySelectorAll(".message-card");
        if (messages.length > MAX_VISIBLE_MESSAGES) {
          // Remove excess messages in batch
          for (let i = MAX_VISIBLE_MESSAGES; i < messages.length; i++) {
            messages[i].remove();
          }
        }

        if (autoScroll) {
          messagesContainer.scrollTop = 0;
        }

        // If there are more messages in buffer, schedule another render
        if (messageBuffer.length > 0) {
          scheduleRender();
        }
      }

      function processMessageBatch(messages, startIndex = 0) {
        const BATCH_SIZE = 5;
        const endIndex = Math.min(startIndex + BATCH_SIZE, messages.length);
        
        for (let i = startIndex; i < endIndex; i++) {
          const msg = messages[i];
          messageBuffer.push({data: msg.data, timestamp: msg.timestamp, isNew: msg.isNew});
        }
        
        scheduleRender();
        
        // Continue processing if there are more messages
        if (endIndex < messages.length) {
          setTimeout(() => processMessageBatch(messages, endIndex), 10);
        }
      }

      function createMessageElement(data, timestamp) {
        const messageCard = document.createElement("div");
        messageCard.className = "message-card";

        // Format time to show date if not from today
        const messageDate = new Date(timestamp);
        const today = new Date();
        const isToday = messageDate.toDateString() === today.toDateString();
        
        const time = isToday 
          ? messageDate.toLocaleTimeString()
          : messageDate.toLocaleDateString() + " " + messageDate.toLocaleTimeString();

        // Handle array of messages with simplified rendering
        let content = "";
        if (Array.isArray(data)) {
          // Limit displayed items to reduce DOM complexity
          const displayItems = data.slice(0, 5); // Show only first 5 items
          const remainingCount = data.length - displayItems.length;
          
          content = displayItems
            .map((item, index) => `
              <div style="margin-bottom: 8px; padding-bottom: 8px; ${index < displayItems.length - 1 ? "border-bottom: 1px solid #ccc;" : ""}">
                  <strong>M3ter ID:</strong> ${item.m3ter_id}<br>
                  <span>${item.message}</span>
              </div>
          `).join("");
          
          if (remainingCount > 0) {
            content += `<div style="font-style: italic; color: #666;">... and ${remainingCount} more items</div>`;
          }
        } else {
          // Truncate long JSON to prevent excessive DOM size
          const jsonString = JSON.stringify(data, null, 2);
          content = jsonString.length > 500 ? 
            `<pre>${jsonString.substring(0, 500)}...</pre>` : 
            `<pre>${jsonString}</pre>`;
        }

        messageCard.innerHTML = `
            <div class="message-header">
                <span class="timestamp">${time}</span>
                <span class="m3ter-id">${Array.isArray(data) ? data.length + " items" : "Data"}</span>
            </div>
            <div class="message-content">
                ${content}
            </div>
        `;

        return messageCard;
      }

      function addError(message) {
        const messageCard = document.createElement("div");
        messageCard.className = "message-card error-message";
        
        // Format time to show date if not from today
        const messageDate = new Date();
        const today = new Date();
        const isToday = messageDate.toDateString() === today.toDateString();
        
        const time = isToday 
          ? messageDate.toLocaleTimeString()
          : messageDate.toLocaleDateString() + " " + messageDate.toLocaleTimeString();
        
        messageCard.innerHTML = `
            <div class="message-header">
                <span class="timestamp">${time}</span>
                <span style="color: #dc3545; font-weight: bold;">ERROR</span>
            </div>
            <div class="message-content">
                ${message}
            </div>
        `;
        messagesContainer.insertBefore(messageCard, messagesContainer.firstChild);
      }

      function updateStatus(status, text) {
        statusText.textContent = text;
        statusIndicator.className = "status-indicator";
        if (status === "connected") {
          statusIndicator.classList.add("connected");
        }
      }

      clearBtn.addEventListener("click", () => {
        // Clear all state
        messageBuffer = [];
        messageCount = 0;
        messageCountEl.textContent = 0;
        
        const messages = messagesContainer.querySelectorAll(".message-card");
        messages.forEach((msg) => msg.remove());

        messagesContainer.innerHTML = `
            <div class="empty-state">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 13V6a2 2 0 00-2-2H6a2 2 0 00-2 2v7m16 0v5a2 2 0 01-2 2H6a2 2 0 01-2-2v-5m16 0h-2.586a1 1 0 00-.707.293l-2.414 2.414a1 1 0 01-.707.293h-3.172a1 1 0 01-.707-.293l-2.414-2.414A1 1 0 006.586 13H4"></path>
                </svg>
                <h3>Waiting for messages...</h3>
                <p>Messages from the Streamr network will appear here in real-time.</p>
            </div>
        `;
      });

      autoScrollToggle.addEventListener("change", (e) => {
        autoScroll = e.target.checked;
      });

      pauseBtn.addEventListener("click", () => {
        isPaused = !isPaused;
        pauseBtn.textContent = isPaused ? "Resume Stream" : "Pause Stream";
        pauseBtn.className = isPaused ? "btn btn-primary" : "btn btn-secondary";
        
        if (isPaused) {
          updateStatus("paused", "Stream Paused");
        } else {
          updateStatus("connected", "Connected to Streamr Stream");
          // Resume processing if there are buffered messages
          if (messageBuffer.length > 0) {
            scheduleRender();
          }
        }
      });

      // Connect on page load
      connect();
    </script>
  </body>
</html>
